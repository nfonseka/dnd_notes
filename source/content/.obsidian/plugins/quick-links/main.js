/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => QuickLinksPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian4 = require("obsidian");

// src/settings.ts
var import_obsidian = require("obsidian");

// src/quick-links.ts
var DEFAULT_QUICK_LINKS = [
  // Wikipedia
  {
    prefix: "w",
    target: "https://www.wikipedia.org/w/index.php?title=Special:Search&search=%s"
  },
  // Blank entry for the settings editor
  {
    prefix: "",
    target: ""
  }
];
function transformLink(link, quickLinksMap) {
  const linkPrefix = getLinkPrefix(link.target);
  if (linkPrefix === "") {
    return null;
  }
  const quickLink = quickLinksMap.get(linkPrefix);
  if (quickLink === void 0) {
    return null;
  }
  const linkHrefNoPrefix = link.target.slice(quickLink.prefix.length + 1);
  const displayText = (
    // [](w:Whatever) --> linkText === ""
    // [[w:Whatever]] --> linkHref === linkText
    //
    // In either case, we should use "Whatever" as the display text.
    //
    // Otherwise, the user has set some custom display text and we should
    // use that.
    link.text === "" || link.target === link.text ? linkHrefNoPrefix : link.text
  );
  const linkTarget = quickLink.target.replace("%s", linkHrefNoPrefix);
  return { target: linkTarget, text: displayText, em: link.em };
}
function getLinkPrefix(linkHref) {
  const linkSplit = linkHref.split(":", 2);
  if (linkSplit.length !== 2) {
    return "";
  }
  return linkSplit[0];
}

// src/settings.ts
var DEFAULT_SETTINGS = {
  useWikiLinkSyntax: true,
  quickLinks: DEFAULT_QUICK_LINKS
};
var QuickLinksSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app2, plugin) {
    super(app2, plugin);
    this.plugin = plugin;
  }
  display() {
    this.containerEl.empty();
    new import_obsidian.Setting(this.containerEl).setName("Use wiki link syntax").setDesc(
      "Use [[w:My link]] syntax instead of [](w:My link). Note that this will cause Obsidian to treat custom links as internal links, for example in autocompletion and graph view."
    ).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.useWikiLinkSyntax).onChange(async (value) => {
        this.plugin.settings.useWikiLinkSyntax = value;
        await this.plugin.saveSettings();
      })
    );
    const div = this.containerEl.createEl("div");
    this.renderQuickLinksSettings(div);
  }
  renderQuickLinksSettings(containerEl) {
    containerEl.empty();
    containerEl.createEl("hr");
    new import_obsidian.Setting(containerEl).setName("Manage quick links").setHeading().addButton((btn) => {
      btn.setButtonText("New quick link").setCta();
      btn.onClick(async (e) => {
        this.plugin.settings.quickLinks.push({
          prefix: "",
          target: ""
        });
        this.renderQuickLinksSettings(containerEl);
      });
    });
    const quickLinksArray = this.plugin.settings.quickLinks;
    for (let i = 0; i < quickLinksArray.length; i++) {
      const quickLink = quickLinksArray[i];
      new import_obsidian.Setting(containerEl).setName(`Quick link ${i + 1}`).addText((text) => {
        text.setPlaceholder("Link prefix").setValue(quickLink.prefix).onChange(async (value) => {
          quickLink.prefix = value;
          await this.plugin.saveSettings();
        });
      }).addText((text) => {
        text.setPlaceholder("Target URL with %s").setValue(quickLink.target).onChange(async (value) => {
          quickLink.target = value;
          await this.plugin.saveSettings();
        });
      }).addButton((btn) => {
        btn.setButtonText("Delete").setWarning();
        btn.onClick(async (e) => {
          this.plugin.settings.quickLinks.splice(i, 1);
          await this.plugin.saveSettings();
          this.renderQuickLinksSettings(containerEl);
        });
      });
    }
    new import_obsidian.Setting(containerEl).addButton((btn) => {
      btn.setButtonText("Reset to defaults").setWarning();
      btn.onClick(async (e) => {
        this.plugin.settings.quickLinks = DEFAULT_QUICK_LINKS;
        await this.plugin.saveSettings();
        this.renderQuickLinksSettings(containerEl);
      });
    });
  }
};
function getQuickLinksMap(settings) {
  const quickLinks = settings.quickLinks;
  const quickLinksMap = /* @__PURE__ */ new Map();
  for (const quickLink of quickLinks) {
    if (quickLink.prefix === "") {
      continue;
    }
    quickLinksMap.set(quickLink.prefix, quickLink);
  }
  return quickLinksMap;
}

// src/reading-mode.ts
var import_obsidian2 = require("obsidian");
function markdownPostProcessor(element, context, settings) {
  var _a, _b;
  const useWikiLinkSyntax = settings.useWikiLinkSyntax;
  const quickLinksMap = getQuickLinksMap(settings);
  const linkElements = element.querySelectorAll("a");
  for (let linkElement of linkElements) {
    if (!useWikiLinkSyntax && linkElement.classList.contains("internal-link")) {
      continue;
    }
    const linkHref = (_a = linkElement.getAttribute("href")) != null ? _a : "";
    const linkText = (_b = linkElement.innerText) != null ? _b : "";
    const rawLink = { text: linkText, target: linkHref, em: false };
    const maybeLink = transformLink(rawLink, quickLinksMap);
    if (maybeLink !== null) {
      context.addChild(new QuickLinkRenderChild(linkElement, maybeLink));
    }
  }
}
var QuickLinkRenderChild = class extends import_obsidian2.MarkdownRenderChild {
  constructor(containerEl, link) {
    super(containerEl);
    this.link = link;
  }
  onload() {
    const element = this.containerEl.createEl("a", {
      attr: {
        class: "external-link",
        href: this.link.target,
        rel: "noopener",
        target: "_blank"
      },
      text: this.link.text
    });
    this.containerEl.replaceWith(element);
  }
};

// src/live-preview.ts
var import_language = require("@codemirror/language");
var import_state = require("@codemirror/state");
var import_view = require("@codemirror/view");
var import_obsidian3 = require("obsidian");
var LivePreviewQuickLinksPluginValue = class {
  constructor(view) {
    this.slices = [];
    this.decorations = this.buildDecorations(view);
  }
  update(update) {
    if (update.docChanged || update.viewportChanged || update.selectionSet) {
      this.decorations = this.buildDecorations(update.view);
    }
  }
  buildDecorations(view) {
    if (!view.state.field(import_obsidian3.editorLivePreviewField)) {
      return import_view.Decoration.none;
    }
    const builder = new import_state.RangeSetBuilder();
    this.slices = [];
    this.findQuickLinks(view, this.slices);
    this.processQuickLinks(view, builder);
    return builder.finish();
  }
  findQuickLinks(view, slices) {
    const settings = (
      // @ts-ignore
      app.plugins.plugins["quick-links"].settings
    );
    const quickLinksMap = getQuickLinksMap(settings);
    const nodes = [];
    for (let { from, to } of view.visibleRanges) {
      (0, import_language.syntaxTree)(view.state).iterate({
        from,
        to,
        enter: (node) => {
          console.debug("Found node:", node.node.type.name);
          nodes.push(node.node);
        }
      });
    }
    if (settings.useWikiLinkSyntax) {
      const plainInternalLinkPattern = [
        "formatting-link_formatting-link-start",
        "hmd-internal-link",
        "formatting-link_formatting-link-end"
      ];
      console.debug("Searching for plain internal links");
      for (const chunk of findChunks(nodes, plainInternalLinkPattern)) {
        console.assert(chunk.length === 3);
        const from = chunk[0].from;
        const to = chunk[chunk.length - 1].to;
        const target = view.state.sliceDoc(chunk[1].from, chunk[1].to);
        const link = { text: "", target, em: chunk[0].name.startsWith("em") };
        console.debug("Found link (plain internal)", link);
        this.handleLink(link, false, { from, to }, slices, quickLinksMap);
      }
      const pipedInternalLinkPattern = [
        "formatting-link_formatting-link-start",
        "hmd-internal-link_link-has-alias",
        "hmd-internal-link_link-alias-pipe",
        "hmd-internal-link_link-alias",
        "formatting-link_formatting-link-end"
      ];
      console.debug("Searching for piped internal links");
      for (const chunk of findChunks(nodes, pipedInternalLinkPattern)) {
        console.assert(chunk.length === 5);
        const from = chunk[0].from;
        const to = chunk[chunk.length - 1].to;
        const target = view.state.sliceDoc(chunk[1].from, chunk[1].to);
        const text = view.state.sliceDoc(chunk[3].from, chunk[3].to);
        const link = { text, target, em: chunk[0].name.startsWith("em") };
        console.debug("Found link (piped internal)", link);
        this.handleLink(link, false, { from, to }, slices, quickLinksMap);
      }
    }
    const externalLinkPattern1 = [
      "formatting_formatting-link_link",
      "link",
      "formatting_formatting-link_link",
      "formatting_formatting-link-string_string_url",
      "string_url",
      "formatting_formatting-link-string_string_url"
    ];
    console.debug("Searching for external links");
    for (const chunk of findChunks(nodes, externalLinkPattern1)) {
      console.assert(chunk.length === 6);
      const from = chunk[0].from;
      const to = chunk[chunk.length - 1].to;
      const target = view.state.sliceDoc(chunk[4].from, chunk[4].to);
      const text = view.state.sliceDoc(chunk[1].from, chunk[1].to);
      const link = { text, target, em: false };
      console.debug("Found link (external)", link);
      this.handleLink(link, true, { from, to }, slices, quickLinksMap);
    }
    const externalLinkPattern2 = [
      "formatting_formatting-link_hmd-barelink_link",
      "formatting_formatting-link-string_string_url",
      "string_url",
      "formatting_formatting-link-string_string_url"
    ];
    console.debug("Searching for external links (pattern2)");
    for (const chunk of findChunks(nodes, externalLinkPattern2)) {
      console.assert(chunk.length === 4);
      const from = chunk[0].from;
      const to = chunk[chunk.length - 1].to;
      const target = view.state.sliceDoc(chunk[2].from, chunk[2].to);
      const text = "";
      const link = { text, target, em: false };
      console.debug("Found link (external)", link);
      this.handleLink(link, true, { from, to }, slices, quickLinksMap);
    }
  }
  handleLink(link, externalLink, { from, to }, slices, quickLinksMap) {
    const maybeLink = transformLink(link, quickLinksMap);
    if (maybeLink !== null) {
      slices.push({
        linkToInsert: maybeLink,
        externalLink,
        from,
        to
      });
    }
  }
  processQuickLinks(view, builder) {
    this.slices.sort((a, b) => a.from - b.from);
    const cursorHead = view.state.selection.main.head;
    for (let slice of this.slices) {
      if (slice.from <= cursorHead && cursorHead <= slice.to) {
        continue;
      }
      const widget = new QuickLinksWidget(slice);
      builder.add(slice.from, slice.to, import_view.Decoration.replace({ widget }));
    }
  }
};
function findChunks(nodes, pattern) {
  const chunks = [];
  for (let i = 0; i <= nodes.length - pattern.length; i++) {
    const chunk = nodes.slice(i, i + pattern.length);
    if (doesChunkMatch(chunk, pattern)) {
      chunks.push(chunk);
    }
  }
  return chunks;
}
function doesChunkMatch(chunk, pattern) {
  for (let i = 0; i < chunk.length; i++) {
    if (!chunk[i].name.includes(pattern[i])) {
      return false;
    }
  }
  return true;
}
var QuickLinksWidget = class extends import_view.WidgetType {
  constructor(slice) {
    super();
    this.slice = slice;
  }
  toDOM(view) {
    const el = document.createElement("a");
    el.innerText = this.slice.linkToInsert.text;
    if (!this.slice.externalLink) {
      el.classList.add("external-link");
    }
    el.setAttribute("href", this.slice.linkToInsert.target);
    el.setAttribute("rel", "noopener");
    el.setAttribute("target", "_blank");
    if (this.slice.linkToInsert.em) {
      const outer = document.createElement("em");
      outer.appendChild(el);
      return outer;
    }
    return el;
  }
};
var LivePreviewQuickLinksPlugin = import_view.ViewPlugin.fromClass(
  LivePreviewQuickLinksPluginValue,
  {
    decorations: (value) => value.decorations
  }
);

// src/main.ts
var QuickLinksPlugin = class extends import_obsidian4.Plugin {
  async onload() {
    await this.loadSettings();
    this.addSettingTab(new QuickLinksSettingTab(this.app, this));
    this.registerMarkdownPostProcessor(
      (element, context) => markdownPostProcessor(element, context, this.settings)
    );
    this.registerEditorExtension(LivePreviewQuickLinksPlugin);
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
